"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfResolveHypermediaLinksTraversePruneShapetrees = void 0;
const bus_rdf_resolve_hypermedia_links_1 = require("@comunica/bus-rdf-resolve-hypermedia-links");
/**
 * A comunica Traverse Prune Shapetrees RDF Resolve Hypermedia Links Actor.
 */
class ActorRdfResolveHypermediaLinksTraversePruneShapetrees extends bus_rdf_resolve_hypermedia_links_1.ActorRdfResolveHypermediaLinks {
    constructor(args) {
        super(args);
    }
    async test(action) {
        if (!action.metadata.traverse) {
            throw new Error(`Actor ${this.name} requires a 'traverse' metadata entry.`);
        }
        if (!action.metadata.shapetrees) {
            throw new Error(`Actor ${this.name} requires a 'shapetrees' metadata entry.`);
        }
        return true;
    }
    async run(action) {
        // Clone the action without shapetrees
        const subAction = { ...action, metadata: { ...action.metadata } };
        delete subAction.metadata.shapetrees;
        // Obtain links and shapetrees from metadata
        let links = action.metadata.traverse;
        const applicable = action.metadata.shapetrees.applicable;
        const nonApplicable = action.metadata.shapetrees.nonApplicable;
        // Prune links from non-applicable shapetrees
        links = links.filter(link => {
            for (const shapeTree of nonApplicable) {
                if (this.urlMatchesTemplate(link.url, shapeTree.uriTemplate)) {
                    return false;
                }
            }
            return true;
        });
        // Prioritize links from applicable shapetrees over other links
        // TODO: check if URL template matches with one of applicable (do in a different actor?)
        // Update metadata in action
        subAction.metadata.traverse = links;
        // TODO: how to handle more complex URI templates recursively?
        // Forward updated metadata to next actor
        return this.mediatorRdfResolveHypermediaLinks.mediate(subAction);
    }
    /**
     * Check if the given URL matches with the given URL template.
     * @param url a URL.
     * @param template a URL template.
     */
    urlMatchesTemplate(url, template) {
        // TODO: this is not able to handle more complex cases, see https://datatracker.ietf.org/doc/html/rfc6570
        const templateRegex = new RegExp(template.replace(/\{[^}]*\}/gu, '.+'), 'u');
        return templateRegex.test(url);
    }
}
exports.ActorRdfResolveHypermediaLinksTraversePruneShapetrees = ActorRdfResolveHypermediaLinksTraversePruneShapetrees;
//# sourceMappingURL=ActorRdfResolveHypermediaLinksTraversePruneShapetrees.js.map