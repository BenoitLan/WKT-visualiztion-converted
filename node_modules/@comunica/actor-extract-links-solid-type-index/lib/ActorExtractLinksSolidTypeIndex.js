"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorExtractLinksSolidTypeIndex = void 0;
const actor_init_query_1 = require("@comunica/actor-init-query");
const bus_extract_links_1 = require("@comunica/bus-extract-links");
const context_entries_1 = require("@comunica/context-entries");
const context_entries_link_traversal_1 = require("@comunica/context-entries-link-traversal");
const rdf_store_stream_1 = require("rdf-store-stream");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
/**
 * A comunica Solid Type Index Extract Links Actor.
 */
class ActorExtractLinksSolidTypeIndex extends bus_extract_links_1.ActorExtractLinks {
    constructor(args) {
        super(args);
        this.queryEngine = new actor_init_query_1.QueryEngineBase(args.actorInitQuery);
    }
    async test(action) {
        if (!action.context.get(context_entries_1.KeysInitQuery.query)) {
            throw new Error(`Actor ${this.name} can only work in the context of a query.`);
        }
        if (!action.context.get(context_entries_1.KeysQueryOperation.operation)) {
            throw new Error(`Actor ${this.name} can only work in the context of a query operation.`);
        }
        return true;
    }
    async run(action) {
        // Determine links to type indexes
        const typeIndexes = await this.extractTypeIndexLinks(action.metadata);
        // Dereference all type indexes, and collect them in one record
        const typeLinks = (await Promise.all(typeIndexes
            .map(typeIndex => this.dereferenceTypeIndex(typeIndex, action.context))))
            // eslint-disable-next-line unicorn/prefer-object-from-entries
            .reduce((acc, typeLinksInner) => {
            for (const [type, linksInner] of Object.entries(typeLinksInner)) {
                if (!acc[type]) {
                    acc[type] = [];
                }
                acc[type].push(...linksInner);
            }
            return acc;
        }, {});
        // Avoid further processing if no type index entries were discovered
        if (Object.keys(typeLinks).length === 0) {
            return { links: [] };
        }
        // Different behaviour depending on whether or not we match type index entries with the current query.
        if (this.onlyMatchingTypes) {
            // Filter out those links that match with the query
            return {
                links: await this.getLinksMatchingQuery(typeLinks, action.context.get(context_entries_1.KeysInitQuery.query), action.context.get(context_entries_1.KeysQueryOperation.operation)),
            };
        }
        // Follow all type links in the other case
        const links = [];
        for (const linksInner of Object.values(typeLinks)) {
            links.push(...linksInner);
        }
        return { links };
    }
    /**
     * Extract links to type index from the metadata stream.
     * @param metadata A metadata quad stream.
     */
    extractTypeIndexLinks(metadata) {
        return new Promise((resolve, reject) => {
            const typeIndexesInner = [];
            // Forward errors
            metadata.on('error', reject);
            // Invoke callback on each metadata quad
            metadata.on('data', (quad) => {
                if (this.typeIndexPredicates.includes(quad.predicate.value)) {
                    typeIndexesInner.push(quad.object.value);
                }
            });
            // Resolve to discovered links
            metadata.on('end', () => {
                resolve(typeIndexesInner);
            });
        });
    }
    /**
     * Determine all entries within the given type index.
     * @param typeIndex The URL of a type index.
     * @param context The context.
     * @return typeLinks A record mapping class URLs to an array of links.
     */
    async dereferenceTypeIndex(typeIndex, context) {
        // Parse the type index document
        const response = await this.mediatorDereferenceRdf.mediate({ url: typeIndex, context });
        const store = await (0, rdf_store_stream_1.storeStream)(response.data);
        // Query the document to extract all type registrations
        const bindingsArray = await (await this.queryEngine
            .queryBindings(`
        PREFIX solid: <http://www.w3.org/ns/solid/terms#>
        SELECT ?class ?instance WHERE {
          _:registration a solid:TypeRegistration;
            solid:forClass ?class;
            (solid:instance|solid:instanceContainer) ?instance.
        }`, {
            sources: [store],
            [context_entries_link_traversal_1.KeysRdfResolveHypermediaLinks.traverse.name]: false,
        })).toArray();
        // Collect links per type
        const typeLinks = {};
        for (const bindings of bindingsArray) {
            const type = bindings.get('class').value;
            if (!typeLinks[type]) {
                typeLinks[type] = [];
            }
            typeLinks[type].push({ url: bindings.get('instance').value });
        }
        return typeLinks;
    }
    /**
     * Determine all links that match with the current query pattern.
     * @param typeLinks The type index links.
     * @param query The original query that is being executed.
     * @param pattern The current pattern that is being evaluated and traversed in.
     */
    async getLinksMatchingQuery(typeLinks, query, pattern) {
        // Collect all subjects in the original query that refer to a specific type
        const typeSubjects = {};
        sparqlalgebrajs_1.Util.recurseOperation(query, {
            [sparqlalgebrajs_1.Algebra.types.PATTERN](queryPattern) {
                if (queryPattern.predicate.value === ActorExtractLinksSolidTypeIndex.RDF_TYPE &&
                    queryPattern.object.termType === 'NamedNode') {
                    const type = queryPattern.object.value;
                    if (!typeSubjects[type]) {
                        typeSubjects[type] = [];
                    }
                    typeSubjects[type].push(queryPattern.subject);
                }
                return false;
            },
        });
        // Check if the current pattern has any of the allowed subjects,
        // and consider the type index entry's links in that case.
        const links = [];
        for (const [type, subjects] of Object.entries(typeSubjects)) {
            const currentLinks = typeLinks[type];
            if (currentLinks && subjects.some(subject => subject.equals(pattern.subject))) {
                links.push(...currentLinks);
            }
        }
        return links;
    }
}
exports.ActorExtractLinksSolidTypeIndex = ActorExtractLinksSolidTypeIndex;
ActorExtractLinksSolidTypeIndex.RDF_TYPE = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type';
//# sourceMappingURL=ActorExtractLinksSolidTypeIndex.js.map