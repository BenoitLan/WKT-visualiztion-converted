"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfMetadataExtractShapetrees = void 0;
const actor_init_query_1 = require("@comunica/actor-init-query");
const bus_rdf_metadata_extract_1 = require("@comunica/bus-rdf-metadata-extract");
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const parseLink = require("parse-link-header");
const rdf_store_stream_1 = require("rdf-store-stream");
const relative_to_absolute_iri_1 = require("relative-to-absolute-iri");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const ShapeTree_1 = require("./ShapeTree");
const shexParser = require('@shexjs/parser');
const shexVisitor = require('@shexjs/visitor');
/**
 * A comunica Shapetrees RDF Metadata Extract Actor.
 */
class ActorRdfMetadataExtractShapetrees extends bus_rdf_metadata_extract_1.ActorRdfMetadataExtract {
    constructor(args) {
        super(args);
        this.queryEngine = new actor_init_query_1.QueryEngineBase(args.actorInitQuery);
    }
    async test(action) {
        if (!action.context.get(context_entries_1.KeysInitQuery.query)) {
            throw new Error(`Actor ${this.name} can only work in the context of a query.`);
        }
        if (!action.context.get(context_entries_1.KeysQueryOperation.operation)) {
            throw new Error(`Actor ${this.name} can only work in the context of a query operation.`);
        }
        return true;
    }
    async run(action) {
        const applicable = [];
        const nonApplicable = [];
        const shapeTreeLocatorUrl = this.discoverShapeTreeLocator(action.headers);
        if (shapeTreeLocatorUrl) {
            const shapeTreeLocators = await this.fetchShapeTreesLocatorShapeTrees(shapeTreeLocatorUrl, action.context);
            for (const shapeTreeLocator of shapeTreeLocators) {
                const shapeTrees = await this.dereferenceShapeTrees(shapeTreeLocator, action.url, action.context);
                for (const shapeTree of shapeTrees) {
                    if (this.shapeTreeMatchesQuery(shapeTree, action.context.get(context_entries_1.KeysInitQuery.query), action.context.get(context_entries_1.KeysQueryOperation.operation))) {
                        applicable.push(shapeTree);
                    }
                    else {
                        nonApplicable.push(shapeTree);
                    }
                }
            }
        }
        return {
            metadata: {
                shapetrees: {
                    applicable,
                    nonApplicable,
                },
            },
        };
    }
    /**
     * Extracts the shape tree locator URL from the headers
     * @param headers A headers record object
     */
    discoverShapeTreeLocator(headers) {
        if (headers) {
            const links = parseLink(headers.get('link'));
            if (links) {
                // TODO: remove old rel type
                const shapeTree = links[ActorRdfMetadataExtractShapetrees.IRI_SHAPETREE] ||
                    links[ActorRdfMetadataExtractShapetrees.IRI_SHAPETREE_OLD];
                if (shapeTree) {
                    return shapeTree.url;
                }
            }
        }
    }
    /**
     * Fetch all shapetrees identified by the given shape tree locator.
     * @param shapeTreeLocatorUrl A shape tree locator URL.
     * @param context An action context.
     */
    async fetchShapeTreesLocatorShapeTrees(shapeTreeLocatorUrl, context) {
        // Parse the Shape Tree locator document
        const response = await this.mediatorDereferenceRdf.mediate({ url: shapeTreeLocatorUrl, context });
        const store = await (0, rdf_store_stream_1.storeStream)(response.data);
        // Query the document to extract all Shape Trees
        // TODO: is this query correct? Data doesn't correspond to spec.
        const bindingsArray = await (await this.queryEngine
            .queryBindings(`
        PREFIX st: <http://www.w3.org/ns/shapetree#>
        SELECT ?shapeTree WHERE {
          <${shapeTreeLocatorUrl}> st:hasShapeTreeLocator/st:hasShapeTree ?shapeTree.
        }`, { sources: [store] })).toArray();
        return bindingsArray
            .map(bindings => bindings.get('shapeTree').value);
    }
    /**
     * Dereference the given shape tree.
     * @param shapeTreeReference A shape tree URL.
     * @param baseUrl The base URL for URI templates.
     * @param context An action context.
     */
    async dereferenceShapeTrees(shapeTreeReference, baseUrl, context) {
        // Parse the Shape Tree document
        const response = await this.mediatorDereferenceRdf.mediate({
            url: shapeTreeReference,
            // TODO: this is just to cope with the problem that demo servers expose use text/plain
            mediaType: 'text/turtle',
            // TODO: pass dummy context because the demo servers reject anything with DPoP auth
            context: new core_1.ActionContext(),
        });
        const store = await (0, rdf_store_stream_1.storeStream)(response.data);
        // Query the document to extract all Shapes
        const bindingsArray = await (await this.queryEngine
            .queryBindings(`
        PREFIX st: <http://www.w3.org/ns/shapetree#>
        SELECT ?shapeTree ?shape ?uriTemplate WHERE {
          <${shapeTreeReference}> st:contains ?shapeTree.
          ?shapeTree st:validatedBy ?shape;
                     st:matchesUriTemplate ?uriTemplate.
        }`, { sources: [store] })).toArray();
        return await Promise.all(bindingsArray
            .map(async (bindings) => {
            let shapeIri = bindings.get('shape').value;
            // TODO: workaround for incorrect prefix use on https://shapetrees.pub/ts/medical-record/shapetree
            if (shapeIri === 'medshape:MedicalRecordShape') {
                shapeIri = 'http://shapes.pub/ns/medical-record/shex#MedicalRecordShape';
            }
            const shapeExpression = await this.dereferenceShape(shapeIri, context);
            // TODO: what is the correct base URL for relative URI templates?
            const uriTemplate = (0, relative_to_absolute_iri_1.resolve)(bindings.get('uriTemplate').value, baseUrl);
            return new ShapeTree_1.ShapeTree(bindings.get('shapeTree').value, shapeExpression, uriTemplate);
        }));
    }
    /**
     * Dereference a shape
     * @param shapeIri The URL of a shape definition.
     * @param context An action context.
     */
    async dereferenceShape(shapeIri, context) {
        // Fetch the shape
        const response = await this.mediatorHttp.mediate({
            input: shapeIri,
            // TODO: pass dummy context because servers may reject anything with DPoP auth
            context: new core_1.ActionContext(),
        });
        let data = await response.text();
        // TODO: temp workaround because the test dataset uses the wrong BASE
        data = data.replace('PREFIX med: <http://shapes.pub/ns/medical-record/terms#>', 'PREFIX med: <https://shapes.pub/ns/medical-record/terms#MedicalRecord>');
        // Parse as ShEx shape
        const parser = shexParser.construct(shapeIri);
        const schema = parser.parse(data);
        if (schema.shapes) {
            for (const shapeExpression of schema.shapes) {
                const shape = shapeExpression;
                // TODO: workaround for https://github.com/shexjs/shex.js/issues/93
                if (shape.id === 'https://shapes.pub/ns/medical-record/MedicalRecordShape') {
                    shape.id = 'http://shapes.pub/ns/medical-record/shex#MedicalRecordShape';
                }
                if (shape.id === shapeIri) {
                    return shape;
                }
            }
        }
        throw new Error(`Could not find a shape at ${shapeIri}`);
    }
    /**
     * Check if the given shape tree matches with the current pattern in the global query.
     * @param shapeTree A shape tree to match with the query and pattern.
     * @param query The original query that is being executed.
     * @param pattern The current pattern that is being evaluated and traversed in.
     */
    shapeTreeMatchesQuery(shapeTree, query, pattern) {
        // Collect all predicates in the shape
        // TODO: improve shape-query matching, by e.g. also matching rdf:type
        const visitor = shexVisitor();
        const shapePredicates = [];
        visitor.visitTripleConstraint = (tripleConstraint) => {
            shapePredicates.push(tripleConstraint.predicate);
        };
        visitor.visitShape(shapeTree.shape);
        // Collect all subjects in the original query that match with any of the predicates
        // TODO: we can probably re-organize some things to achieve better performance
        const subjects = [];
        sparqlalgebrajs_1.Util.recurseOperation(query, {
            [sparqlalgebrajs_1.Algebra.types.PATTERN](queryPattern) {
                if (shapePredicates.includes(queryPattern.predicate.value)) {
                    subjects.push(queryPattern.subject);
                }
                return false;
            },
        });
        // Check if the current pattern has any of the allowed subjects.
        return subjects.some(subject => subject.equals(pattern.subject));
    }
}
exports.ActorRdfMetadataExtractShapetrees = ActorRdfMetadataExtractShapetrees;
ActorRdfMetadataExtractShapetrees.IRI_SHAPETREE = 'http://www.w3.org/ns/shapetrees#ShapeTreeLocator';
ActorRdfMetadataExtractShapetrees.IRI_SHAPETREE_OLD = 'http://shapetrees.org/#ShapeTree';
//# sourceMappingURL=ActorRdfMetadataExtractShapetrees.js.map