"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActorRdfResolveHypermediaLinksTraverseAnnotateSourceGraph = void 0;
const stream_1 = require("stream");
const bus_rdf_resolve_hypermedia_links_1 = require("@comunica/bus-rdf-resolve-hypermedia-links");
const context_entries_link_traversal_1 = require("@comunica/context-entries-link-traversal");
const rdf_data_factory_1 = require("rdf-data-factory");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * A comunica Traverse Annotate Source Graph RDF Resolve Hypermedia Links Actor.
 */
class ActorRdfResolveHypermediaLinksTraverseAnnotateSourceGraph extends bus_rdf_resolve_hypermedia_links_1.ActorRdfResolveHypermediaLinks {
    constructor(args) {
        super(args);
    }
    async test(action) {
        if (action.context.getSafe(context_entries_link_traversal_1.KeysRdfResolveHypermediaLinks.annotateSources) !== 'graph') {
            throw new Error(`Actor ${this.name} can only work when graph annotation is enabled.`);
        }
        return true;
    }
    async run(action) {
        const result = await this.mediatorRdfResolveHypermediaLinks
            .mediate({ ...action, context: action.context.delete(context_entries_link_traversal_1.KeysRdfResolveHypermediaLinks.annotateSources) });
        return {
            ...result,
            links: result.links.map(link => this.mapLink(link)),
        };
    }
    /**
     * Adds a transformer to the given link that transforms all quads that are returned from the link's document
     * into quads that have the link's url as graph.
     * @param link The link to transform.
     */
    mapLink(link) {
        return {
            ...link,
            async transform(input) {
                // First apply the existing transformer if it exists
                if (link.transform) {
                    input = await link.transform(input);
                }
                // Then apply our new transformation
                return input.pipe(new stream_1.Transform({
                    objectMode: true,
                    transform(quad, encoding, callback) {
                        if (quad.graph.termType === 'DefaultGraph') {
                            return callback(undefined, DF.quad(quad.subject, quad.predicate, quad.object, DF.namedNode(link.url)));
                        }
                        return callback(undefined, quad);
                    },
                }));
            },
        };
    }
}
exports.ActorRdfResolveHypermediaLinksTraverseAnnotateSourceGraph = ActorRdfResolveHypermediaLinksTraverseAnnotateSourceGraph;
//# sourceMappingURL=ActorRdfResolveHypermediaLinksTraverseAnnotateSourceGraph.js.map